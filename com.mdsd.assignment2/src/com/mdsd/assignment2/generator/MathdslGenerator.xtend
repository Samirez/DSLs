/*
 * generated by Xtext 2.30.0
 */
package com.mdsd.assignment2.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.mdsd.assignment2.mathdsl.MathExp
import java.util.HashMap
import java.util.Map
import com.mdsd.assignment2.mathdsl.Plus
import com.mdsd.assignment2.mathdsl.Expression
import com.mdsd.assignment2.mathdsl.Minus
import com.mdsd.assignment2.mathdsl.Mult
import com.mdsd.assignment2.mathdsl.Div
import com.mdsd.assignment2.mathdsl.Num
import com.mdsd.assignment2.mathdsl.LetBinding
import com.mdsd.assignment2.mathdsl.VarBinding
import com.mdsd.assignment2.mathdsl.VarUse
import javax.swing.JOptionPane

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile('Math.txt', 'Mathematical operations to perform: ' + 
			resource.allContents
				.filter(MathExp)
				.map[variables]
				.join(', '))
	}
}
/*
 * generated by Xtext 2.25.0
 */
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */

class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
		//System.out.println('MathExp = '+math.displayPanel)
		//JOptionPane.showMessageDialog(null, result ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	def static Map<String, Integer> compute(MathExp math){
	//def int compute(MathExp math){
		/*val value = math.variables.exp.computeExp
		val name = math.name
		variables.put(name, value)*/
		//math.exp.computeExp(variables)
		math.variables.forEach[varbinding |
			val value = varbinding.exp.computeExp
			val varName = varbinding.name
			variables.put(varName, value)
		]
		/*for (variable: math.variables){
			variables.put(variable.name, variable.exp.computeExp)
		}*/
		return variables
	}
	def static int computeExp(Expression exp){
		switch (exp){
			Plus: exp.left.computeExp + exp.right.computeExp
			Minus: exp.left.computeExp - exp.right.computeExp
			Mult: exp.left.computeExp * exp.right.computeExp
			Div: exp.left.computeExp / exp.right.computeExp
			Num: exp.value
			LetBinding: exp.body.computeExp
			VarBinding: exp.exp.computeExp
			VarUse: exp.ref.computeBinding
			default: throw new Error('Invalid expression')
		}
	}

	def static dispatch int computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.exp.computeExp			
		variables.get(binding.name)
	}
	def static dispatch int computeBinding(LetBinding binding){
		binding.binding.computeExp
	}
	def static int computeExp(LetBinding exp) {
		exp.body.computeExp
	}
	def static int computeExp(VarBinding binding) {
		variables.put(binding.name, binding.exp.computeExp)
		return variables.get(binding.name)
	}
	/*def static Map<String, Integer> bind(Map<String, Integer> env, String name, int value){
		val env2 = new HashMap<String, Integer>(env)
		env2.put(name, value)
		return env2
	}
	def String displayPanel(MathExp math){
		math.exp.displayExp
	}
	def String displayExp(Expression exp){
		'('+switch (exp){
			Plus: exp.left.displayExp+'+'+exp.right.displayExp
			Minus: exp.left.displayExp+'-'+exp.right.displayExp
			Mult: exp.left.displayExp+'*'+exp.right.displayExp
			Div: exp.left.displayExp+'/'+exp.right.displayExp
			Num: Integer.toString(exp.value)
			//Var: exp.id
			//VarReference: exp.reference.computeVariable
			Let: '''let «exp» = «exp.binding.displayExp» in «exp.body.displayExp» end'''
			default: throw new Error('Invalid expression')
		}+')'
	}*/
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
		// Print complete expression
		printExpression(result)
	}
	
	def void printExpression(Map<String, Integer> result) {
		// Print expression
		for (entry : result.entrySet()) {
			println(entry.getValue())
		}
	}
	
}

