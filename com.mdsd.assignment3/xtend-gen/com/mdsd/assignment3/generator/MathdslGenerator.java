/**
 * generated by Xtext 2.30.0
 */
package com.mdsd.assignment3.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import com.mdsd.assignment3.mathdsl.Binding;
import com.mdsd.assignment3.mathdsl.Div;
import com.mdsd.assignment3.mathdsl.Expression;
import com.mdsd.assignment3.mathdsl.External;
import com.mdsd.assignment3.mathdsl.ExternalUse;
import com.mdsd.assignment3.mathdsl.LetBinding;
import com.mdsd.assignment3.mathdsl.MathExp;
import com.mdsd.assignment3.mathdsl.MathNumber;
import com.mdsd.assignment3.mathdsl.Minus;
import com.mdsd.assignment3.mathdsl.Mult;
import com.mdsd.assignment3.mathdsl.Parenthesis;
import com.mdsd.assignment3.mathdsl.Plus;
import com.mdsd.assignment3.mathdsl.VarBinding;
import com.mdsd.assignment3.mathdsl.VariableUse;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.JOptionPane;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MathdslGenerator extends AbstractGenerator {
  private static Map<String, Integer> variables;

  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final MathExp math = Iterators.<MathExp>filter(resource.getAllContents(), MathExp.class).next();
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("math_expression/");
    String _name = math.getName();
    _builder.append(_name);
    _builder.append(".java");
    fsa.generateFile(_builder.toString(), MathdslGenerator.generate(math, resource));
  }

  private static ArrayList<String> letMethods = new ArrayList<String>();

  private static int letCounter = 0;

  public static String generate(final MathExp math, final Resource resource) {
    String _xblockexpression = null;
    {
      MathdslGenerator.letMethods.clear();
      MathdslGenerator.letCounter = 0;
      List<External> externals = IteratorExtensions.<External>toList(Iterators.<External>filter(resource.getAllContents(), External.class));
      List<VarBinding> varbindings = IteratorExtensions.<VarBinding>toList(Iterators.<VarBinding>filter(resource.getAllContents(), VarBinding.class));
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("package math_expression;");
      _builder.newLine();
      _builder.append("public class ");
      String _name = math.getName();
      _builder.append(_name);
      _builder.append(" {");
      _builder.newLineIfNotEmpty();
      {
        for(final VarBinding binding : varbindings) {
          _builder.append("\t");
          _builder.append("public int ");
          String _name_1 = binding.getName();
          _builder.append(_name_1, "\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.append("\t");
      _builder.newLine();
      {
        final List<External> _converted_externals = (List<External>)externals;
        int _length = ((Object[])Conversions.unwrapArray(_converted_externals, Object.class)).length;
        boolean _greaterThan = (_length > 0);
        if (_greaterThan) {
          _builder.append("\t");
          _builder.append("private External external;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("public ");
          String _name_2 = math.getName();
          _builder.append(_name_2, "\t");
          _builder.append("(External external) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("\t\t");
          _builder.append("this.external = external;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("}");
          _builder.newLine();
        }
      }
      _builder.append("\t");
      _builder.newLine();
      {
        for(final External external : externals) {
          _builder.append("\t");
          _builder.append("public int ");
          String _name_3 = external.getName();
          _builder.append(_name_3, "\t");
          _builder.append("(");
          {
            int _length_1 = ((Object[])Conversions.unwrapArray(external.getArguments(), Object.class)).length;
            ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length_1, true);
            boolean _hasElements = false;
            for(final Integer argument : _doubleDotLessThan) {
              if (!_hasElements) {
                _hasElements = true;
              } else {
                _builder.appendImmediate(", ", "\t");
              }
              _builder.append("int ");
              _builder.append(((char) (97 + (argument).intValue())), "\t");
            }
          }
          _builder.append("){");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("\t");
          _builder.append("return 0;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("}");
          _builder.newLine();
        }
      }
      _builder.append("\t");
      _builder.newLine();
      _builder.append("public void compute(){");
      _builder.newLine();
      {
        for(final VarBinding binding_1 : varbindings) {
          _builder.append("\t");
          String _name_4 = binding_1.getName();
          _builder.append(_name_4, "\t");
          _builder.append(" = ");
          Expression _expression = binding_1.getExpression();
          ArrayList<String> _arrayList = new ArrayList<String>();
          Object _display = MathdslGenerator.display(_expression, _arrayList);
          _builder.append(_display, "\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.append("}");
      _builder.newLine();
      {
        for(final String letmethod : MathdslGenerator.letMethods) {
          _builder.append("\t");
          _builder.append(letmethod, "\t");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.append("}");
      _builder.newLine();
      _xblockexpression = _builder.toString();
    }
    return _xblockexpression;
  }

  protected static Object _display(final Expression exp, final ArrayList<String> arguments) {
    return null;
  }

  protected static Object _display(final MathNumber number, final ArrayList<String> arguments) {
    return Integer.valueOf(number.getValue());
  }

  protected static String _display(final Plus plus, final ArrayList<String> arguments) {
    StringConcatenation _builder = new StringConcatenation();
    Object _display = MathdslGenerator.display(plus.getLeft(), arguments);
    _builder.append(_display);
    _builder.append(" + ");
    Object _display_1 = MathdslGenerator.display(plus.getRight(), arguments);
    _builder.append(_display_1);
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }

  protected static String _display(final Minus minus, final ArrayList<String> arguments) {
    StringConcatenation _builder = new StringConcatenation();
    Object _display = MathdslGenerator.display(minus.getLeft(), arguments);
    _builder.append(_display);
    _builder.append(" - ");
    Object _display_1 = MathdslGenerator.display(minus.getRight(), arguments);
    _builder.append(_display_1);
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }

  protected static String _display(final Div div, final ArrayList<String> arguments) {
    StringConcatenation _builder = new StringConcatenation();
    Object _display = MathdslGenerator.display(div.getLeft(), arguments);
    _builder.append(_display);
    _builder.append(" / ");
    Object _display_1 = MathdslGenerator.display(div.getRight(), arguments);
    _builder.append(_display_1);
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }

  protected static String _display(final Mult mult, final ArrayList<String> arguments) {
    StringConcatenation _builder = new StringConcatenation();
    Object _display = MathdslGenerator.display(mult.getLeft(), arguments);
    _builder.append(_display);
    _builder.append(" * ");
    Object _display_1 = MathdslGenerator.display(mult.getRight(), arguments);
    _builder.append(_display_1);
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }

  protected static String _display(final Parenthesis parenthesis, final ArrayList<String> arguments) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    Object _display = MathdslGenerator.display(parenthesis.getExpression(), arguments);
    _builder.append(_display);
    _builder.append(")");
    return _builder.toString();
  }

  protected static String _display(final LetBinding binding, final ArrayList<String> arguments) {
    String _xblockexpression = null;
    {
      MathdslGenerator.letCounter++;
      arguments.add(binding.getName());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("letMethod");
      _builder.append(MathdslGenerator.letCounter);
      String methodName = _builder.toString();
      final Function1<String, Boolean> _function = (String x) -> {
        String _name = binding.getName();
        return Boolean.valueOf(Objects.equal(x, _name));
      };
      List<String> relevantArguments = IterableExtensions.<String>toList(IterableExtensions.<String>reject(arguments, _function));
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(" ");
      {
        for(final String argument : relevantArguments) {
          _builder_1.append(", int ");
          _builder_1.append(argument, " ");
        }
      }
      String argumentString = _builder_1.toString();
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append("private int ");
      _builder_2.append(methodName);
      _builder_2.append("(int ");
      String _name = binding.getName();
      _builder_2.append(_name);
      _builder_2.append(argumentString);
      _builder_2.append("){");
      _builder_2.newLineIfNotEmpty();
      _builder_2.append("\t");
      _builder_2.append("return ");
      Object _display = MathdslGenerator.display(binding.getBody(), arguments);
      _builder_2.append(_display, "\t");
      _builder_2.append(";");
      _builder_2.newLineIfNotEmpty();
      _builder_2.append("}");
      _builder_2.newLine();
      MathdslGenerator.letMethods.add(_builder_2.toString());
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append(methodName);
      _builder_3.append("(");
      Object _display_1 = MathdslGenerator.display(binding.getBinding(), arguments);
      _builder_3.append(_display_1);
      {
        for(final String argument_1 : relevantArguments) {
          _builder_3.append(", ");
          _builder_3.append(argument_1);
        }
      }
      _builder_3.append(")");
      _xblockexpression = _builder_3.toString();
    }
    return _xblockexpression;
  }

  protected static String _display(final VariableUse varUse, final ArrayList<String> arguments) {
    return varUse.getRef().getName();
  }

  protected static String _display(final ExternalUse extUse, final ArrayList<String> arguments) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("this.external.");
    String _name = extUse.getRef().getName();
    _builder.append(_name);
    _builder.append("(");
    {
      EList<Expression> _arguments = extUse.getArguments();
      boolean _hasElements = false;
      for(final Expression argument : _arguments) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(", ", "");
        }
        Object _display = MathdslGenerator.display(argument, arguments);
        _builder.append(_display);
      }
    }
    _builder.append(")");
    return _builder.toString();
  }

  public void displayPanel(final Map<String, Integer> result) {
    String resultString = "";
    Set<Map.Entry<String, Integer>> _entrySet = result.entrySet();
    for (final Map.Entry<String, Integer> entry : _entrySet) {
      String _resultString = resultString;
      String _key = entry.getKey();
      String _plus = ("var " + _key);
      String _plus_1 = (_plus + " = ");
      Integer _value = entry.getValue();
      String _plus_2 = (_plus_1 + _value);
      String _plus_3 = (_plus_2 + "\n");
      resultString = (_resultString + _plus_3);
    }
    JOptionPane.showMessageDialog(null, resultString, "Math Language", JOptionPane.INFORMATION_MESSAGE);
  }

  public static Map<String, Integer> compute(final MathExp math) {
    Map<String, Integer> _xblockexpression = null;
    {
      HashMap<String, Integer> _hashMap = new HashMap<String, Integer>();
      MathdslGenerator.variables = _hashMap;
      EList<VarBinding> _variables = math.getVariables();
      for (final VarBinding varBinding : _variables) {
        MathdslGenerator.computeExpression(varBinding);
      }
      _xblockexpression = MathdslGenerator.variables;
    }
    return _xblockexpression;
  }

  protected static int _computeExpression(final VarBinding binding) {
    MathdslGenerator.variables.put(binding.getName(), Integer.valueOf(MathdslGenerator.computeExpression(binding.getExpression())));
    return (MathdslGenerator.variables.get(binding.getName())).intValue();
  }

  protected static int _computeExpression(final MathNumber exp) {
    return exp.getValue();
  }

  protected static int _computeExpression(final Plus exp) {
    int _computeExpression = MathdslGenerator.computeExpression(exp.getLeft());
    int _computeExpression_1 = MathdslGenerator.computeExpression(exp.getRight());
    return (_computeExpression + _computeExpression_1);
  }

  protected static int _computeExpression(final Minus exp) {
    int _computeExpression = MathdslGenerator.computeExpression(exp.getLeft());
    int _computeExpression_1 = MathdslGenerator.computeExpression(exp.getRight());
    return (_computeExpression - _computeExpression_1);
  }

  protected static int _computeExpression(final Mult exp) {
    int _computeExpression = MathdslGenerator.computeExpression(exp.getLeft());
    int _computeExpression_1 = MathdslGenerator.computeExpression(exp.getRight());
    return (_computeExpression * _computeExpression_1);
  }

  protected static int _computeExpression(final Div exp) {
    int _computeExpression = MathdslGenerator.computeExpression(exp.getLeft());
    int _computeExpression_1 = MathdslGenerator.computeExpression(exp.getRight());
    return (_computeExpression / _computeExpression_1);
  }

  protected static int _computeExpression(final LetBinding exp) {
    return MathdslGenerator.computeExpression(exp.getBody());
  }

  protected static int _computeExpression(final VariableUse exp) {
    return MathdslGenerator.computeBinding(exp.getRef());
  }

  protected static int _computeBinding(final VarBinding binding) {
    Integer _xblockexpression = null;
    {
      boolean _containsKey = MathdslGenerator.variables.containsKey(binding.getName());
      boolean _not = (!_containsKey);
      if (_not) {
        MathdslGenerator.computeExpression(binding);
      }
      _xblockexpression = MathdslGenerator.variables.get(binding.getName());
    }
    return (_xblockexpression).intValue();
  }

  protected static int _computeBinding(final LetBinding binding) {
    return MathdslGenerator.computeExpression(binding.getBinding());
  }

  public static Object display(final Expression div, final ArrayList<String> arguments) {
    if (div instanceof Div) {
      return _display((Div)div, arguments);
    } else if (div instanceof ExternalUse) {
      return _display((ExternalUse)div, arguments);
    } else if (div instanceof LetBinding) {
      return _display((LetBinding)div, arguments);
    } else if (div instanceof MathNumber) {
      return _display((MathNumber)div, arguments);
    } else if (div instanceof Minus) {
      return _display((Minus)div, arguments);
    } else if (div instanceof Mult) {
      return _display((Mult)div, arguments);
    } else if (div instanceof Parenthesis) {
      return _display((Parenthesis)div, arguments);
    } else if (div instanceof Plus) {
      return _display((Plus)div, arguments);
    } else if (div instanceof VariableUse) {
      return _display((VariableUse)div, arguments);
    } else if (div != null) {
      return _display(div, arguments);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(div, arguments).toString());
    }
  }

  public static int computeExpression(final EObject exp) {
    if (exp instanceof Div) {
      return _computeExpression((Div)exp);
    } else if (exp instanceof LetBinding) {
      return _computeExpression((LetBinding)exp);
    } else if (exp instanceof MathNumber) {
      return _computeExpression((MathNumber)exp);
    } else if (exp instanceof Minus) {
      return _computeExpression((Minus)exp);
    } else if (exp instanceof Mult) {
      return _computeExpression((Mult)exp);
    } else if (exp instanceof Plus) {
      return _computeExpression((Plus)exp);
    } else if (exp instanceof VarBinding) {
      return _computeExpression((VarBinding)exp);
    } else if (exp instanceof VariableUse) {
      return _computeExpression((VariableUse)exp);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(exp).toString());
    }
  }

  public static int computeBinding(final Binding binding) {
    if (binding instanceof LetBinding) {
      return _computeBinding((LetBinding)binding);
    } else if (binding instanceof VarBinding) {
      return _computeBinding((VarBinding)binding);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(binding).toString());
    }
  }
}
