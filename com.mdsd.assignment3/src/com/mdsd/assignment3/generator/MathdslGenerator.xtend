/*
 * generated by Xtext 2.30.0
 */
package com.mdsd.assignment3.generator

import com.mdsd.assignment3.mathdsl.Div
import com.mdsd.assignment3.mathdsl.LetBinding
import com.mdsd.assignment3.mathdsl.MathExp
import com.mdsd.assignment3.mathdsl.MathNumber
import com.mdsd.assignment3.mathdsl.Minus
import com.mdsd.assignment3.mathdsl.Mult
import com.mdsd.assignment3.mathdsl.Plus
import com.mdsd.assignment3.mathdsl.VarBinding
import com.mdsd.assignment3.mathdsl.VariableUse
import java.util.ArrayList
import java.util.HashMap
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.mdsd.assignment3.mathdsl.External
import com.mdsd.assignment3.mathdsl.Expression
import com.mdsd.assignment3.mathdsl.ExternalUse
import com.mdsd.assignment3.mathdsl.Parenthesis
import javax.swing.JOptionPane

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathdslGenerator extends AbstractGenerator {
	
	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		//val result = math.compute
		fsa.generateFile('''math_expression/«math.name».java''', generate(math, resource));
		//result.displayPanel
		
	}
	static var letMethods = new ArrayList<String>;
	static var letCounter = 0;
	
	def static String generate(MathExp math, Resource resource){
		letMethods.clear();
		letCounter = 0;
		var externals = resource.allContents.filter(External).toList
		var varbindings = resource.allContents.filter(VarBinding).toList
		'''
			package math_expression;
			public class «math.name» {
				«FOR binding : varbindings»
					public int «binding.name»;
				«ENDFOR»
				
				«IF externals.length > 0»
					private External external;
					public «math.name»(External external) {
							this.external = external;
					}
				«ENDIF»
				
				«FOR external : externals»
					public int «external.name»(«FOR argument : 0..<external.arguments.length SEPARATOR ', '»int «(97 + argument) as char»«ENDFOR»){
						return 0;
					}
				«ENDFOR»
				
			public void compute(){
				«FOR binding : varbindings»
					«binding.name» = «binding.expression.display(new ArrayList())»;
				«ENDFOR»
			}
				«FOR letmethod : letMethods»
					«letmethod»
				«ENDFOR»
			}
		'''
	}
	def static dispatch display(Expression exp, ArrayList<String> arguments){
		
	}
	def static dispatch display(MathNumber number, ArrayList<String> arguments){
		return number.value
	}
	def static dispatch String display(Plus plus, ArrayList<String> arguments){
		'''
			«plus.left.display(arguments)» + «plus.right.display(arguments)»
		'''
	}
	def static dispatch String display(Minus minus, ArrayList<String> arguments){
		'''
			«minus.left.display(arguments)» - «minus.right.display(arguments)»
		'''
	}
	def static dispatch String display(Div div, ArrayList<String> arguments){
		'''
			«div.left.display(arguments)» / «div.right.display(arguments)»
		'''
	}
	def static dispatch String display(Mult mult, ArrayList<String> arguments){
		'''
			«mult.left.display(arguments)» * «mult.right.display(arguments)»
		'''
	}
	def static dispatch String display(Parenthesis parenthesis, ArrayList<String> arguments)
	{
		'''(«parenthesis.expression.display(arguments)»)'''
	}
	def static dispatch String display(LetBinding binding, ArrayList<String> arguments){
		letCounter++;
		arguments.add(binding.name);
		var methodName = '''letMethod«letCounter»'''
		var relevantArguments = arguments.reject([x | x==binding.name]).toList
		var argumentString = ''' «FOR argument : relevantArguments», int «argument»«ENDFOR»'''
		letMethods.add('''
			private int «methodName»(int «binding.name»«argumentString»){
				return «binding.body.display(arguments)»;
			}
		''');
		'''«methodName»(«binding.binding.display(arguments)»«FOR argument: relevantArguments», «argument»«ENDFOR»)'''
	}
	def static dispatch String display(VariableUse varUse, ArrayList<String> arguments){
		varUse.ref.name
	} 
	def static dispatch String display(ExternalUse extUse, ArrayList<String> arguments){
		'''this.external.«extUse.ref.name»(«FOR argument : extUse.arguments SEPARATOR ', '»«argument.display(arguments)»«ENDFOR»)'''
	}
	
	
	
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def static compute(MathExp math) {
		variables = new HashMap()
		for(varBinding: math.variables)
			varBinding.computeExpression()
		variables
	}
	
	def static dispatch int computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}
	
	def static dispatch int computeExpression(MathNumber exp) {
		exp.value
	}

	def static dispatch int computeExpression(Plus exp) {
		exp.left.computeExpression + exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Minus exp) {
		exp.left.computeExpression - exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Mult exp) {
		exp.left.computeExpression * exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Div exp) {
		exp.left.computeExpression / exp.right.computeExpression
	}

	def static dispatch int computeExpression(LetBinding exp) {
		exp.body.computeExpression
	}
	
	def static dispatch int computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}

	def static dispatch int computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression()			
		variables.get(binding.name)
	}
	
	def static dispatch int computeBinding(LetBinding binding){
		binding.binding.computeExpression
	}
	
}