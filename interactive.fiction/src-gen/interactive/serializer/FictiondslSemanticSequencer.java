/*
 * generated by Xtext 2.30.0
 */
package interactive.serializer;

import com.google.inject.Inject;
import interactive.fictiondsl.Announce;
import interactive.fictiondsl.End;
import interactive.fictiondsl.Ending;
import interactive.fictiondsl.Expression;
import interactive.fictiondsl.External;
import interactive.fictiondsl.FictiondslPackage;
import interactive.fictiondsl.Question;
import interactive.fictiondsl.Scenario;
import interactive.fictiondsl.Statement;
import interactive.fictiondsl.Story;
import interactive.fictiondsl.Target;
import interactive.fictiondsl.VarDef;
import interactive.services.FictiondslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FictiondslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FictiondslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FictiondslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FictiondslPackage.ANNOUNCE:
				sequence_Announce(context, (Announce) semanticObject); 
				return; 
			case FictiondslPackage.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case FictiondslPackage.ENDING:
				sequence_Exp(context, (Ending) semanticObject); 
				return; 
			case FictiondslPackage.EXPRESSION:
				if (rule == grammarAccess.getExpRule()) {
					sequence_Evaluate_Exp(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEvaluateRule()) {
					sequence_Evaluate(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case FictiondslPackage.EXTERNAL:
				sequence_External(context, (External) semanticObject); 
				return; 
			case FictiondslPackage.QUESTION:
				sequence_Question(context, (Question) semanticObject); 
				return; 
			case FictiondslPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case FictiondslPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case FictiondslPackage.STORY:
				sequence_Story(context, (Story) semanticObject); 
				return; 
			case FictiondslPackage.TARGET:
				sequence_Target(context, (Target) semanticObject); 
				return; 
			case FictiondslPackage.VAR_DEF:
				sequence_VarDef(context, (VarDef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Announce returns Announce
	 *     SomeRef returns Announce
	 *
	 * Constraint:
	 *     (name=ID expression=Exp (ref=[VarDef|ID] exp=Exp)? target=Target)
	 * </pre>
	 */
	protected void sequence_Announce(ISerializationContext context, Announce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     End returns End
	 *     SomeRef returns End
	 *
	 * Constraint:
	 *     (name=ID expression=Exp (ref=[VarDef|ID] exp=Exp)?)
	 * </pre>
	 */
	protected void sequence_End(ISerializationContext context, End semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Expression
	 *
	 * Constraint:
	 *     (
	 *         number=INT | 
	 *         type=Type | 
	 *         (
	 *             ((add='+' | add='-') ref=[VarDef|ID])? 
	 *             (
	 *                 op='&lt;' | 
	 *                 op='&lt;=' | 
	 *                 op='&gt;' | 
	 *                 op='&gt;=' | 
	 *                 op='==' | 
	 *                 op='!='
	 *             ) 
	 *             exp=Exp
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_Evaluate_Exp(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Evaluate returns Expression
	 *
	 * Constraint:
	 *     (
	 *         ((add='+' | add='-') ref=[VarDef|ID])? 
	 *         (
	 *             op='&lt;' | 
	 *             op='&lt;=' | 
	 *             op='&gt;' | 
	 *             op='&gt;=' | 
	 *             op='==' | 
	 *             op='!='
	 *         ) 
	 *         exp=Exp
	 *     )
	 * </pre>
	 */
	protected void sequence_Evaluate(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Ending
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, Ending semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FictiondslPackage.Literals.ENDING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FictiondslPackage.Literals.ENDING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     External returns External
	 *
	 * Constraint:
	 *     (name=ID type=Type result=Type)
	 * </pre>
	 */
	protected void sequence_External(ISerializationContext context, External semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FictiondslPackage.Literals.EXTERNAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FictiondslPackage.Literals.EXTERNAL__NAME));
			if (transientValues.isValueTransient(semanticObject, FictiondslPackage.Literals.EXTERNAL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FictiondslPackage.Literals.EXTERNAL__TYPE));
			if (transientValues.isValueTransient(semanticObject, FictiondslPackage.Literals.EXTERNAL__RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FictiondslPackage.Literals.EXTERNAL__RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternalAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getExternalAccess().getResultTypeParserRuleCall_6_0(), semanticObject.getResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Question returns Question
	 *     SomeRef returns Question
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         expression=Exp 
	 *         (type=Type | (exref=[External|ID] type=Type))? 
	 *         (
	 *             (
	 *                 op='&lt;' | 
	 *                 op='&lt;=' | 
	 *                 op='&gt;' | 
	 *                 op='&gt;=' | 
	 *                 op='==' | 
	 *                 op='!='
	 *             ) 
	 *             condition=Exp
	 *         )? 
	 *         ref=[VarDef|ID]? 
	 *         target+=Target+
	 *     )
	 * </pre>
	 */
	protected void sequence_Question(ISerializationContext context, Question semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     (name=ID var+=VarDef* statement+=Statement*)
	 * </pre>
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (announce+=Announce | end+=End | question+=Question)
	 * </pre>
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Story returns Story
	 *
	 * Constraint:
	 *     (name=ID external+=External* scenario+=Scenario*)
	 * </pre>
	 */
	protected void sequence_Story(ISerializationContext context, Story semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Target returns Target
	 *
	 * Constraint:
	 *     (
	 *         ref=[SomeRef|ID] 
	 *         ((exref=[External|ID] vardef=[VarDef|ID]? condition=Exp?) | (vardef=[VarDef|ID] res=Exp?) | condition=Exp | (vardef=[VarDef|ID] condition=Exp))?
	 *     )
	 * </pre>
	 */
	protected void sequence_Target(ISerializationContext context, Target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VarDef returns VarDef
	 *
	 * Constraint:
	 *     (name=ID type=Exp)
	 * </pre>
	 */
	protected void sequence_VarDef(ISerializationContext context, VarDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FictiondslPackage.Literals.VAR_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FictiondslPackage.Literals.VAR_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, FictiondslPackage.Literals.VAR_DEF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FictiondslPackage.Literals.VAR_DEF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarDefAccess().getTypeExpParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}
